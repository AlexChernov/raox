<html>
<head>
<link rel="stylesheet" type="text/css" href="../styles/rao_general.css">
<link rel="stylesheet" href="../styles/rao_highlight.css">
<meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
<script src="../scripts/thirdparty/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script src="../scripts/thirdparty/jquery-2.1.4.min.js"></script>
<script src="../scripts/table_of_contents.js"></script>
</head>
<body>
<h2>Образцы</h2>
<p>Образцы формируют часть базы знаний модели, позволяющую реализовать подход сканирования активностей. Они представляют собой набор правил и предусловий их выполнения, изменяющих состояние модели.</p>
<p>Описание образцов имеет следующий вид:</p>
<pre><code class="rao"><i>тип_образца</i> <i>Имя_образца</i>(<i>описание_параметров_образца</i>) {
    <i>описание_релевантных_ресурсов_образца</i>
    <i>тело_образца</i>
}</code></pre>
<p>Определены образцы двух типов:</p>
<table style="width:100%">
    <tr>
        <th width="20%">Тип образца</th>
        <th width="80%">Описание</th>
    </tr>
    <tr>
        <td><pre><code class="rao">operation</code></pre></td>
        <td>Описывают модифицированные продукционные правила, учитывающие временные связи</td>
    </tr>
    <tr>
        <td><pre><code class="rao">rule</code></pre></td>
        <td>Описывают обычные продукционные правила</td>
    </tr>
</table>
<h3>Условие запуска, релевантные ресурсы</h3>
<p>Образец может быть запущен в результате успешного подбора всех описанных в нем релевантных ресурсов. Конструкция подбора каждого релевантного ресурса одинакова для всех типов образцов и имеет следующий вид:</p>
<pre><code class="rao">relevant <i>имя_релевантного_ресурса</i> = <i>правило_подбора_ресурса</i></code></pre>
<h4>Конкретный ресурс в качестве релевантного</h4>
<p>Рассмотрим случай, когда необходимо использовать конкретный ресурс в виде релевантного:</p>
<pre><code class="rao">relevant станок = станок_3.onlyif[состояние == Состояние_станка.ЗАКОНЧИЛ_ОБРАБОТКУ]</code></pre>
<p>Общий вид:</p>
<pre><code class="rao">relevant имя_релевантного_ресурса = имя_существующего_ресурса.onlyif[<i>условие_отбора</i>]</code></pre>
<h4>Подбор релевантного ресурса из ресурсов указанного типа</h4>
<p>Релевантным может стать может стать один ресурс указанного типа, например:</p>
<pre><code class="rao">enum Состояние_станка {свободен, загружается, готов_к_обработке}

type Станок {
    int номер;
    Состояние_станка состояние;
}

resource станок_1 = Станок.create(1, Состояние_станка.загружается);
resource станок_2 = Станок.create(2, Состояние_станка.свободен);
resource станок_3 = Станок.create(3, Состояние_станка.свободен);
resource станок_4 = Станок.create(4, Состояние_станка.готов_к_обработке);

operation Этап_обработки() {
    // Подбор любого станка из имеющихся, будет выбран станок_1
    relevant исполнительный_станок_1 = Станок.accessible.any;

    // Подбор любого свободного станка, будет выбран станок_2
    relevant исполнительный_станок_2 = Станок.accessible.filter[состояние == Состояние_станка.свободен].any;

    // Подбор свободного станка с максимальным номером, будет выбран станок_3
    relevant исполнительный_станок_3 = Станок.accessible.filter[состояние == Состояние_станка.свободен].maxBySafe[номер];

    // ...
}
</code></pre>
<p>Общий вид:</p>
<pre><code class="rao">relevant имя_релевантного_ресурса = Имя_типа.accessible.filter[<i>условие_отбора</i>].&lt;критерий_выбора_единственного_ресурса&gt;</code></pre>
<p>Сначала все доступные (<code class="rao">accessible</code>) ресурсы указанного типа проходят фильтрацию (<code class="rao">filter</code>). В результате формируется список, каждый ресурс которого является претендентом, чтобы стать релевантным. Из них нужно выбрать одного. Отбор происходит с помощью следующих методов:</p>
<table style="width:100%">
    <tr>
        <th width="40%">Имя метода</th>
        <th width="60%">Описание</th>
    </tr>
    <tr>
        <td><pre><code class="rao">any</code></pre></td>
        <td>Выбор любого ресурса из группы. Как правило, первого, но это не гарантируется. Самый быстрый отбор.</td>
    </tr>
    <tr>
        <td><pre><code class="rao">minBySafe[<i>арифметическое_выражение</i>]</code></pre></td>
        <td>Выбор ресурса, для которого указанное арифметическое выражение имеет наименьшее значение</td>
    </tr>
    <tr>
        <td><pre><code class="rao">maxBySafe[<i>арифметическое_выражение</i>]</code></pre></td>
        <td>Выбор ресурса, для которого указанное арифметическое выражение имеет наибольшее значение</td>
    </tr>
</table>
<h4>Групповой подбор релевантных ресурсов</h4>
<h5>Ошибка последовательного выбора</h5>
<p>Релевантные ресурсы выбираются последовательно и без возвращений, т.е. выбранный ресурс не будет перевыбран. Это может привести к проблеме: при подборе следующего ресурса окажется, что образец не может быть выполнен из-за неудачного подбора предыдущего. Например:</p>
<pre><code class="rao">enum Состояние_детали {ожидает_обработки, обрабатывается, обработана}
type Деталь {
    Тип_обработки тип_обработки;
    Состояние_детали состояние;
    double длительность_обработки;
}

enum Тип_обработки {токарная, фрезерная}
enum Состояние_станка {свободен, работает}
type Станок {
    Тип_обработки тип_обработки;
    Состояние_станка состояние;
}

resource деталь_1 = Деталь.create(Тип_обработки.токарная, Состояние_детали.ожидает_обработки, 10);
resource деталь_2 = Деталь.create(Тип_обработки.токарная, Состояние_детали.ожидает_обработки, 20);
resource деталь_3 = Деталь.create(Тип_обработки.фрезерная, Состояние_детали.ожидает_обработки, 40);

resource станок_1 = Станок.create(Тип_обработки.токарная, Состояние_станка.свободен);
resource станок_2 = Станок.create(Тип_обработки.фрезерная, Состояние_станка.свободен);

operation Обработка() {
    relevant деталь = Деталь.accessible.filter[состояние == Состояние_детали.ожидает_обработки].minBySafe [
        длительность_обработки
    ];
    relevant станок = Станок.accessible.filter [
        тип_обработки == деталь.тип_обработки &amp;&amp; состояние == Состояние_станка.свободен
    ].any;

    set begin() {
        деталь.состояние = Состояние_детали.обрабатывается;
        станок.состояние = Состояние_станка.работает;
    }

    set duration() {
        return деталь.длительность_обработки;
    }

    set end() {
        деталь.состояние = Состояние_детали.обработана;
        станок.состояние = Состояние_станка.свободен;
    }
}

logic Model {
    activity обработка = new Activity(Обработка.create());
}
</code></pre>
<pre><code class="rao">ES 0.0 Tracing started
RC 0.0 деталь_1 = {токарная, ожидает_обработки, 10.0}
RC 0.0 деталь_2 = {токарная, ожидает_обработки, 20.0}
RC 0.0 деталь_3 = {фрезерная, ожидает_обработки, 40.0}
RC 0.0 станок_1 = {токарная, свободен}
RC 0.0 станок_2 = {фрезерная, свободен}
ES 0.0 Simulation started
EB 0.0 обработка[0](деталь_1, станок_1)
RK 0.0 деталь_1 = {токарная, обрабатывается, 10.0}
RK 0.0 станок_1 = {токарная, работает}
EF 10.0 обработка[0](деталь_1, станок_1)
RK 10.0 деталь_1 = {токарная, обработана, 10.0}
RK 10.0 станок_1 = {токарная, свободен}
EB 10.0 обработка[1](деталь_2, станок_1)
RK 10.0 деталь_2 = {токарная, обрабатывается, 20.0}
RK 10.0 станок_1 = {токарная, работает}
EB 10.0 обработка[2](деталь_3, станок_2)
RK 10.0 деталь_3 = {фрезерная, обрабатывается, 40.0}
RK 10.0 станок_2 = {фрезерная, работает}
EF 30.0 обработка[1](деталь_2, станок_1)
RK 30.0 деталь_2 = {токарная, обработана, 20.0}
RK 30.0 станок_1 = {токарная, свободен}
EF 50.0 обработка[2](деталь_3, станок_2)
RK 50.0 деталь_3 = {фрезерная, обработана, 40.0}
RK 50.0 станок_2 = {фрезерная, свободен}
ES 50.0 Simulation finished: no more events
</code></pre>
<p>Чтобы избежать подобного, процедура подбора должна проанализировать все возможные комбинации. Для этого используется конструкция <code class="rao">relevantSet</code>. Конечно, это приводит к падению быстродействия.<br>Пусть модель задана следующими ресурсами:</p>
<pre><code class="rao">enum Тип_обработки {токарная, фрезерная}
enum Состояние_станка {свободен, загружается, готов_к_обработке,
        работает, разгружается, закончил_обработку, требует_переналадки, требует_ремонта}
enum Состояние_детали {ожидает_обработки, обрабатывается, обработана}

type Станок {
    Тип_обработки тип_обработки;
    Состояние_станка состояние;
}

type Деталь {
    Тип_обработки тип_обработки;
    Состояние_детали состояние;
    double время_обработки;
}

Деталь.create(Тип_обработки.токарная, Состояние_детали.ожидает_обработки, 10);
Деталь.create(Тип_обработки.токарная, Состояние_детали.ожидает_обработки, 20);
Деталь.create(Тип_обработки.фрезерная, Состояние_детали.ожидает_обработки, 40);

Станок.create(Тип_обработки.токарная, Состояние_станка.свободен);
Станок.create(Тип_обработки.фрезерная, Состояние_станка.свободен);</code></pre>
<p>В образце обработки требуется подобрать деталь с наименьшим временем обработки и подходящий для ее обработки станок.<br>Указание способа подбора для каждого ресурса отдельно:</p>
<pre><code class="rao">operation обработка() {
    relevant деталь = Деталь.accessible(деталь.состояние == Состояние_детали.ожидает_обработки).withMin(деталь.время_обработки);
    relevant станок = Станок.accessible(станок.тип_обработки == деталь.тип_обработки &#38;&#38;
        станок.состояние == Состояние_станка.свободен);

    // описание тела образца
    // на время обработки станку выставляется состояние "работает"
    // детали выставляется состояние "обрабатывается"
}</code></pre>
<p>При первом подборе ресурсов в приведенном выше образце будет выбрана деталь, требующая токарной обработки, со временем обработки равным 10 и токарный станок. При втором подборе окажется, что минимальное время обработки имеет оставшаяся из деталей, требующая токарной обработки. Однако токарный станок уже занят и условие <code class="rao">тип_обработки == деталь.тип_обработки</code> выполнено не будет. Несмотря на то, что в наличии есть ожидающая деталь, требующая фрезерной обработки, и фрезерный станок, образец выполнен не будет.<br>Подбор ресурсов из всех возможных комбинаций позволит избежать этой ситуации:</p>
<pre><code class="rao">operation обработка() {
    relevant деталь = Деталь.accessible(деталь.состояние == Состояние_детали.ожидает);
    relevant станок = Станок.accessible(станок.тип_обработки == деталь.тип_обработки &#38;&#38;
        станок.состояние == Состояние_станка.свободен);

    relevantSet withMin(деталь.время_обработки);

    // описание тела образца
    // на время обработки станку выставляется состояние "работает"
    // детали выставляется состояние "обрабатывается"
}</code></pre>
<p>В этом случае сначала будут подобраны все возможные пары станка и детали, а затем будет выбрана та из них, для которой время обработки детали минимально.</p>
<h3>Образцы типа operation</h3>
<p>В теле образцов типа <code class="rao">operation</code> описываются инструкции, выполняемые в начале и в конце операции, а также вычисление ее длительности. Для этого для операции задаются три метода:</p>
<table style="width:100%">
    <tr>
        <th width="30%">Имя метода</th>
        <th width="70%">Описание</th>
    </tr>
    <tr>
        <td><pre><code class="rao">duration()</code></pre></td>
        <td>Задание длительности выполнения операций</td>
    </tr>
    <tr>
        <td><pre><code class="rao">begin()</code></pre></td>
        <td>Описание инструкций, которые должны выполняться в начале выполнения операций</td>
    </tr>
    <tr>
        <td><pre><code class="rao">end()</code></pre></td>
        <td>Описание инструкций, которые должны выполняться в конце выполнения операций</td>
    </tr>
</table>
<pre><code class="rao">operation этап_обработки_2() {
    relevant исполнительный_станок_1 = Станок.accessible(исполнительный_станок_1.состояние == Состояние_станка.свободен).first();
    relevant обрабатываемая_деталь = Деталь.accessible(обрабатываемая_деталь.этап_обработки == 2 &#38;&#38;
        обрабатываемая_деталь.состояние == Состояние_детали.ожидает_обработки);

    set duration() {
        return обрабатываемая_деталь.длительность_обработки;
    }

    set begin() {
        обрабатываемая_деталь.состояние = Состояние_детали.обрабатывается;
        исполнительный_станок_1.состояние = Состояние.работает;
    }

    set end() {
        исполнительный_станок_1.состояние = Состояние.свободен;
        обрабатываемая_деталь.состояние = Состояние_детали.обработана;
    }
}</code></pre>
<p>Если длительность не задана, она принимается равной нулю. Если не заданы методы <code class="rao">begin</code> или <code class="rao">end</code>, то в начале и в конце операции соответственно состояние модели не меняется.</p>
<h3>Образцы типа rule</h3>
<p>В теле образцов типа <code class="rao">rule</code> определяется один метод:</p>
<table style="width:100%">
    <tr>
        <th width="30%">Имя метода</th>
        <th width="70%">Описание</th>
    </tr>
    <tr>
        <td><pre><code class="rao">execute()</code></pre></td>
        <td>Описание инструкций, которые должны быть выполнены в момент выполнения образца</td>
    </tr>
</table>
<pre><code class="rao">rule вывоз_обработанных_деталей() {
    relevant обработанная_деталь = Деталь.accessible(обработанная_деталь.этап_обработки == 3 &#38;&#38;
        обработанная_деталь.состояние == Состояние_детали.обработана);

    set execute() {
        обработанная_деталь.erase();
    }
}</code></pre>
</body>
</html>

