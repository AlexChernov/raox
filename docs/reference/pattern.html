<html>
<head>
<link rel="stylesheet" type="text/css" href="../styles/rao_general.css">
<link rel="stylesheet" href="../styles/rao_highlight.css">
<meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
<script src="../highlight.js.prebuilt/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</head>
<body>
<div id="wrapper">
    <div id="sidebar-wrapper">
        <div class="sidebar-nav">
            <h2><div align="center">Содержание</div></h2>
            <li><a href="../reference/base.html">Базовые возможности языка</a></li>
            <li><a href="../reference/resource.html">Ресурсы</a></li>
            <li><a href="../reference/event.html">События</a></li>
            <li><a href="../reference/pattern.html">Образцы</a></li>
            <li><a href="../reference/dpt.html">Точки принятия решений</a></li>
            <li><a href="../reference/dpt.html">Поиск решения на графе</a></li>
            <li><a href="../reference/sequence.html">Последовательности</a></li>
            <li><a href="../reference/constant.html">Константы</a></li>
            <li><a href="../reference/function.html">Функции</a></li>
            <li><a href="../reference/result.html">Результаты моделирования</a></li>
        </div>
    </div>
    <div id="page-content-wrapper"><div class="page-content">

<h2>Образцы</h2>
<p>Образцы формируют часть базы знаний модели, позволяющую реализовать подход сканирования активностей. Образцы представляют собой набор правил и предусловий их выполнения, изменяющих состояние модели.</p>
<p>Описание образцов имеет следующий вид:</p>
<pre><code class="rao"><i>тип_образца</i> <i>имя_образца</i>(<i>описание_параметров_образца</i>) {
    <i>описание_релевантных_ресурсов_образца</i>
    <i>тело_образца</i>
}</code></pre>
<p>Определены образцы двух типов:</p>
<table style="width:100%">
    <tr>
        <th width="20%">Тип образца</th>
        <th width="80%">Описание</th>
    </tr>
    <tr>
        <td><pre><code class="rao">operation</code></pre></td>
        <td>Описывают модифицированные продукционные правила, учитывающие временные связи.</td>
    </tr>
    <tr>
        <td><pre><code class="rao">rule</code></pre></td>
        <td>Описывают обычные продукционные правила.</td>
    </tr>
</table>
<h3>Условие выполнения</h3>
<p>Условием выполнения образца является успешный подбор всех описанных в нем релевантных ресурсов. Конструкция подбора каждого релевантного ресурса одинакова для всех типов образцов и имеет следующий вид:</p>
<pre><code class="rao">relevant <i>имя_релевантного_ресурса</i> = <i>правило_подбора_ресурса</i></code></pre>
<p>Подбор релевантных ресурсов осуществляется с помощью метода <code class="rao">select(<i>условие_подбора_ресурса</i>)</code>. В случае, если метод вызывается у конкретного ресурса, этот ресурс подбирается как релевантный, только если его состояние удовлетворяет указанному условию. Если метод вызывается у типа ресурса, отбираются все ресурсы данного типа, удовлетворяющие условию. Для отбора всех ресурсов данного типа независимо от их параметров вместо условия подбора ресурса указывается ключевое слово <code class="rao">any</code>. Выбор единственного ресурса из отобранной группы осуществляется с помощью следующих методов:</p>
<table style="width:100%">
    <tr>
        <th width="40%">Имя метода</th>
        <th width="60%">Описание</th>
    </tr>
    <tr>
        <td><pre><code class="rao">first()</code></pre></td>
        <td>Выбор первого ресурса из группы.</td>
    </tr>
    <tr>
        <td><pre><code class="rao">withMin(<i>арифметическое_выражение</i>)</code></pre></td>
        <td>Выбор ресурса, для которого указанное арифметическое выражение имеет наименьшее значение.</td>
    </tr>
    <tr>
        <td><pre><code class="rao">withMax(<i>арифметическое_выражение</i>)</code></pre></td>
        <td>Выбор ресурса, для которого указанное арифметическое выражение имеет наибольшее значение.</td>
    </tr>
</table>
<p>В случае, если не один из методов явно не вызван, по умолчанию выбирается первый ресурс из группы.</p>
<p>Для всех примеров ниже определены следующие типы ресурсов:</p>
<pre><code class="rao">enum Состояние_станка {свободен, загружается, готов_к_обработке,
        работает, разгружается, закончил_обработку, требует_переналадки, требует_ремонта};

enum Состояние_детали {ожидает_обработки, обрабатывается, обработана};

type Станок {
    int номер;
    Состояние_станка состояние;
    double длительность_обработки;
}

type Деталь {
    int номер;
    int этап_обработки;
    Состояние_детали состояние;
}</code></pre>
<p>Примеры подбора релевантных ресурсов по различным признакам:</p>
<pre><code class="rao">operation этап_обработки_1() {
    //подбор станка номер 1 только в случае, если он свободен
    relevant исполнительный_станок_1 = станок_1.select(состояние == Состояние_станка.свободен);

    //подбор любого токарного станка из имеющихся - fist обязательно
    relevant исполнительный_станок_2 = Станок.select(any);

    //подбор любого свободного станка
    relevant исполнительный_станок_3 = Станок.select(состояние == Состояние_станка.свободен).first();

    //подбор свободного станка с минимальной длительностью обработки
    relevant исполнительный_станок_4 = Станок.select(состояние == Состояние_станка.свободен).withMin(длительность_обработки);

    //описание тела образца
    //...
}
</code></pre>
<p>При указании способа выбора релевантного ресурса из группы для каждого ресурса отдельно релевантные ресурсы выбираются последовательно без возвращений, то есть выбранный ранее ресурс не может быть изменен, если при подборе следующего окажется, что образец не может быть выполнен из-за неудачного подбора предыдущих ресурсов. Если необходимо избежать подобной ситуации, подбор конкретных ресурсов можно провести с учетом анализа всех возможных по предусловиям комбинаций. Это осуществляется с помощью конструкции <code class="rao">relevantSet</code> после описания релевантных ресурсов.</p>
<pre><code class="rao">operation этап_обработки_1() {
    relevant исполнительный_станок_1 = Станок.select(состояние == Состояние_станка.свободен);
    relevant исполнительный_станок_2 = Станок.select(состояние == Состояние_станка.свободен);
    relevant исполнительный_станок_3 = Станок.select(состояние == Состояние_станка.свободен);

    relevantSet withMin(исполнительный_станок_1.длительность_обработки
            + исполнительный_станок_2.длительность_обработки
            + исполнительный_станок_3.длительность_обработки);

    //описание тела образца
    //...
}</code></pre>
<h3>Образцы типа operation</h3>
<p>В теле образцов типа <code class="rao">operation</code> описываются инструкции, выполняемые в начале и в конце операции, а так же вычисление ее длительности. Для этого для операции задаются три метода:</p>
<table style="width:100%">
    <tr>
        <th width="30%">Имя метода</th>
        <th width="70%">Описание</th>
    </tr>
    <tr>
        <td><pre><code class="rao">duration()</code></pre></td>
        <td>Задание длительности выполнение операций.</td>
    </tr>
    <tr>
        <td><pre><code class="rao">begin()</code></pre></td>
        <td>Описание инструкций, которые должны выполняться в начале выполнения операций.</td>
    </tr>
    <tr>
        <td><pre><code class="rao">end()</code></pre></td>
        <td>Описание инструкций, которые должны выполняться в конце выполнения операций.</td>
    </tr>
</table>
<p>Задание методов образцам осуществляется с помощью ключевого слова <code class="rao">set</code>.</p>
<pre><code class="rao">operation этап_обработки_2() {
    relevant исполнительный_станок_1 = Станок.select(состояние == Состояние_станка.свободен).first();
    relevant обрабатываемая_деталь = Деталь.select(этап_обработки == 2 &#38;&#38; состояние == Состояние_детали.ожидает_обработки);

    set duration() {
        return исполнительный_станок_1.длительность_обработки;
    }

    set begin() {
        обрабатываемая_деталь.состояние == Состояние_детали.обрабатывается;
        исполнительный_станок_1.состояние = Состояние.работает;
    }

    set end() {
        исполнительный_станок_1.состояние = Состояние.свободен;
        обрабатываемая_деталь.состояние == Состояние_детали.обработана;
    }
}</code></pre>
<p>В случае, если длительность операции не задана, она принимается равной нулю. В случае, если не заданы методы <code class="rao">begin</code> или <code class="rao">end</code>, то в начале и в конце операции соответственно состояние модели не меняется.</p>
<h3>Образцы типа rule</h3>
<p>В теле образцов типа <code class="rao">rule</code> определеяется один метод:</p>
<table style="width:100%">
    <tr>
        <th width="30%">Имя метода</th>
        <th width="70%">Описание</th>
    </tr>
    <tr>
        <td><pre><code class="rao">execute()</code></pre></td>
        <td>Описание инструкций, которые должны быть выполнены в момент выполнения образца.</td>
    </tr>
</table>
<p>Задание методов, как и для операций, осуществляется с помощью ключевого слова <code class="rao">set</code>.</p>
<pre><code class="rao">rule вывоз_обработанных_деталей() {
    relevant обработанная_деталь = Деталь.select(этап_обработки == 3 &#38;&#38; состояние == Состояние_детали.обработана);

    set execute() {
        обработанная_деталь.erase();
    }
}</code></pre>

</div></div></div>
</body>
</html>
