<html>
<head>
<link rel="stylesheet" type="text/css" href="styles/rao_general.css">
<link rel="stylesheet" href="styles/rao_highlight.css">
<meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
<script src="highlight.js.prebuilt/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</head>
<body>
<h2>Модель службы технической поддержки с одним оператором</h2>
<h3>Содержание модели</h3>
<p>За основу будет взята модель подсчета числа звонков, рассмотренная ранее. Необходимо промоделировать обслуживание заявок единственным оператором в течение рабочего дня, собрать статистику по длине очереди и количеству обслуженных заявок. Время на обслуживание заявки распределено по равномерному закону на интервале от 20 до 40 минут.</p>
<h3>Описание ресурсов</h3>
<p>Данная модель так же будет иметь единственный ресурс - службу технической поддержки. Однако параметрами ресурса теперь будет длина очереди, состояние оператора (свободен или занят), а также общее число успешно обслуженных заявок. Для объявления перечислимых значений используется ключевое слово <code>enum</code>.</p>
<pre><code class="rao">enum OperatorState {FREE, BUSY}

type TechSupport {
    OperatorState operatorState
    int queueLength
    int peopleServed
}

resource techSupport is TechSupport.create(OperatorState.FREE, 0, 0)</code></pre>
<h3>Описание действий</h3>
<p>Процесс обслуживание оператором заявки описывается с помощью действий (операций). Описание операций производится с помощью ключевого слова <code>operation</code>.</p>
<pre><code class="rao">operation callProcessingPattern {
    relevant _techSupport is techSupport.select(_techSupport.queueLength > 0
            and _techSupport.operatorState == OperatorState.FREE)
    set duration() {
        return callProcessingTime(20, 40);
    }
    set begin() {
        _techSupport.queueLength--;
        _techSupport.operatorState = OperatorState.BUSY;
    }
    set end() {
        _techSupport.peopleServed++;
        _techSupport.operatorState = OperatorState.FREE;
    }
}</code></pre>
<p>Операции имеют событие начала (описывается в теле метода <code>begin</code>) и событие конца (описывается в теле <code>end()</code>), а также некоторую длительность (задается в <code>duration</code>). В начале операции необходимо уменьшить длину очереди на единицу и выставить оператору состояние "занят". В конце нужно вернуть оператора в состояние "свободен" и увеличить счетчик числа обслуженных звонков на единицу. Операция обслуживание звонка должна выполняться не каждый раз, а только если ресурс, способный производить обслуживание, находится в корректном состоянии, а именно, в очереди есть необслуженные звонки и оператор в данный момент свободен. Эта проверка производится с помощью механизма релевантных ресурсов. Действие будет выполняться только в том случае, если удалось подобрать все релевантные ресурсы по соответствующим условиям. Условия подбора задаются с помощью метода select(), который может следовать после имени конкретного ресурса, либо после имени типа (в этом случае подбор будет происходить среди всех ресурсов данного типа).</p>
<p>Равномерное распределение задается аналогично тому, как задавалось экспоненциальное в прошлой модели.</p>
<pre><code class="rao">sequence callProcessingTime is double uniform(123456789)</code></pre>
<p>Операции в языке РДО не являются самостоятельными сущностями. Это лишь заготовки, которые должны быть реализованы активностями. Активности проверяются на возможность выполнения каждый раз, когда меняется состояние модели (см. подход сканирования активностей). Список активностей и порядок их сканирования задаются с помощью ключевого слова <code>dpt</code> (decision point).</p>
<pre><code class="rao">dpt model {
    activity callProcessing is callProcessingPattern
}</code></pre>
<p>Связь активности и операции, которую она реализует задается с помощью ключевого слова <code>is</code>.</p>
<h3>Описание собираемых показателей</h3>
<p>Общее количество обслуженных заявок можно получить, используя описанный ранее результат типа <code>getValue</code>. Для сбора подробной статистике по длине очереди, следует использовать результат типа <code>watchParameter</code>.</p>
<pre><code class="rao">result totalPeopleServed is getValue(techSupport.peopleServed)
result queueLengthStatistics is watchParameter(techSupport.queueLength)</code></pre>
<h3>Полный код модели</h3>
<pre><code class="rao">enum OperatorState {FREE, BUSY}

type TechSupport {
    OperatorState operatorState
    int queueLength
    int peopleServed
}

resource techSupport is TechSupport.create(OperatorState.FREE, 0, 0)

event newCall {
    set execute() {
        techSupport.queueLength++;
        newCall.planning(currentTime + newCallInterval(30));
    }
}

operation callProcessingPattern {
    relevant _techSupport is techSupport.select(_techSupport.queueLength > 0
            and _techSupport.operatorState == OperatorState.FREE)
    set duration() {
        return callProcessingTime(20, 40);
    }
    set begin() {
        _techSupport.queueLength--;
        _techSupport.operatorState = OperatorState.BUSY;
    }
    set end() {
        _techSupport.peopleServed++;
        _techSupport.operatorState = OperatorState.FREE;
    }
}

dpt model {
    activity callProcessing is callProcessingPattern
}

set init() {
    newCall.planning(currentTime + newCallInterval(30));
}

set terminateCondition() {
    return currentTime >= 480;
}

sequence newCallInterval is double exponential(123456789)
sequence callProcessingTime is double uniform(123456789)

result totalPeopleServed is getValue(techSupport.peopleServed)
result queueLengthStatistics is watchParameter(techSupport.queueLength)</code></pre>
<h3>Результаты моделирования</h3>
<pre><code class="rao">simple.totalPeopleServed: get_value
    Value: 12

simple.queueLengthStatistics: watch_par
    Last value: 4
    Times registered: 31
    Minimum value: 0
    Maximum value: 5
    Mean: 1.6679632239193745
    Standart deviation: 1.6702152840354767
    Coefficient of variation: 167.24703848509745
    Median: 0.7087612785551503</code></pre>
<p>В данной модели было рассмотрено использование подхода сканирования активностей совместно с событийным подходом для моделирования простой системы массового обслуживания. Было рассмотрено понятие релевантных ресурсов и способ их подбора, а также сбор подробной статистики по какому-либо параметру ресурса.</p>
</body>
</html>
