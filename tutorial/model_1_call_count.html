<html>
<head>
<link rel="stylesheet" type="text/css" href="styles/rao_general.css">
<link rel="stylesheet" href="styles/rao_highlight.css">
<meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
<script src="highlight.js.prebuilt/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</head>
<body>
<h2>Подсчет количества звонков в службу технической поддержки</h2>
<h3>Содержание модели</h3>
<p>Пусть в службу технической поддержки с некоторой частотой (интервал между звонками задается экспоненциальным законом с интенсивностью &#955; = 30) поступают звонки. Необходимо подсчитать, сколько звонков поступит за рабочий день (8 часов).</p>
<h3>Описание ресурсов</h3>
<p>База данных модели будет представлена единственным ресурсом - службой технической поддержки. Для него в простейшей модели необходимо задать только один параметр: состояние число поступивших заявок. Определение нового типа ресурса осуществляется с помощью ключевого слова <code>type</code>.</p>
<pre><code class="rao">type TechSupport {
    int callCount
}</code></pre>
<p>Создание нового ресурса производится с помощью ключевого слова <code>resource</code> и вызова метода <code>create()</code> у желаемого типа. В метод <code>create()</code> передаются начальные значения параметров ресурса. Связь только что созданного ресурса с заданным именем осуществляется с помощью ключевого слова <code>is</code>.</p>
<pre><code class="rao">resource techSupport is TechSupport.create(0)</pre></code>
<h3>Описание последовательностей</h3>
<p>Для модели задано одно случайное распределение, для описания интервала между двумя последовательными звонками. Последовательности описываются в РДО с помощью ключевого слова <code>sequence</code>.</p>
<pre><code class="rao">sequence newCallInterval is double exponential(123456789)</code></pre>
<p>Для создание последовательности необходимо задать ее тип (здесь <code>exponential</code>), тип ее возвращаемого значения, и начальное значение базы генератора. Как и для ресурсов, связь созданной последовательности с некоторым именем осуществляется с помощью <code>is</code>.</p>
<h3>Описание событий</h3>
<p>Для описания логики функционирования модели необходимо определить случайные события (поступление нового звонка), происходящие в системе.</p>
<p>События описываются с помощью ключевого слова </code>event</code>.</p>
<pre><code class="rao">event newCall {
    set execute() {
        techSupport.callCount++;
    }
}</code></pre>
<p>С каждым событием связан метод <code>execute()</code>, который необходимо переопределить с помощью ключевого слова <code>set</code>. В теле метода <code>execute()</code> описываются действия, которые выполняются, когда случается данное событие. В данной модели во время поступления нового звонка, счетчик увеличивается на единицу.</p>
<h3>Инициализация модели</h3>
<p>Для того, чтобы модель смогла функционировать, необходимо переодически планировать событие поступление нового звонка. Чтобы модель смогла начать работу, первый раз событие должно быть запланировано до начала прогона модели. Действия, которые необходимо произвести до начала прогона, описываются в глобальном методе <code>init()</code> модели, который так же можно переопределить с помощью ключевого слова set.</p>
<pre><code class="rao">set init() {
    newCall.planning(currentTime + newCallInterval(30));
}</code></pre>
<p>Планирование событий выполняется с помощью метода <code>planning(double time)</code>, которому в качестве параметра передается момент времени, в который должно быть выполнено событие. Глобальный параметр <code>currentTime</code> позволяет получить текущее модельное время. Для получения интервала по случайному распределению, вызывается описанная ранее последовательность <code>newCallInterval</code>, которой в качестве параметра передается значение интенсивности (30 минут). Метод <code>planning()</code> планирует событие только один раз, поэтому его также необходимо вызывать в теле метода <code>execute()</code> описанного события.</p>
<p>Условие завершение модели задается в методе <code>terminateCondition()</code>.</p>
<pre><code class="rao">set terminateCondition() {
    return currentTime >= 480;
}</code></pre>
<h3>Описание собираемых показателей</h3>
<p>Простейшим примером собираемого показателя будет получение общего количества звонков в конце моделирования. Результаты моделирования описываются с помощью ключевого слова <code>result</code>. Для получения значения в конце моделирования используется результат типа <code>getValue</code>.</p>
<pre><code class="rao">result totalCallCount is getValue(techSupport.callCount)</code></pre>
<h3>Полный код модели</h3>
<pre><code class="rao">type TechSupport {
    int callCount
}

resource techSupport is TechSupport.create(0)

event newCall {
    set execute() {
        techSupport.callCount++;
        newCall.planning(currentTime + newCallInterval(30));
    }
}

set init() {
    newCall.planning(currentTime + newCallInterval(30));
}

set terminateCondition() {
    return currentTime >= 480;
}

sequence newCallInterval is double exponential(123456789)

result totalCallCount is getValue(techSupport.callCount)
</code></pre>
<h3>Результаты моделирования</h3>
<p>Собранные показатели отображаются в окне результатов. Для данной модели можно увидеть, что за рабочий день в службу технической поддержки поступило 17 звонков.</p>
<pre><code class="rao">simple.totalPeopleServed: get_value
    Value: 12</code></pre>
<p>В данной модели было разобрано описание и создание ресурсов, описание и планирование событий, инициализация модели и сбор простейших показателей. В рассмотренной модели звонки приходят и подсчитываются, но их обслуживание не моделируется. Первая полноценная модель с моделированием обслуживания звонков будет рассмотрена в <a href="model_2_single_operator.html">следующем разделе.<a/></p>
</body>
</html>
